━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	    ソースコードジェネレータ for X680x0 version 3.16
		      Copyright (C)1989-1992 K.Abe
		    Copyright (C)1994-1997 R.ShimiZu
		    Copyright (C)1997-2010 Tachibana


────────────────────────────────────

● disの概要

　dis は X680x0/Human68k 用の高機能逆アセンブラです。バイナリ形式の実行
ファイルからアセンブリ言語のソースファイルを生成することができ、ソースコ
ードジェネレータとも呼ばれます。

　dis はまず K.Abe 氏により Oh!X '90 6月号で DIS.X version 1.00d が発表
され、その Bug fix and version up 版が Free Ware として公開されました。
同氏により version 2.06β までのバージョンアップが行われ、その時点でサポ
ートが終了しました。

　その後 R.ShimiZu 氏が dis を 68010-68040 の命令やコプロセッサ命令に対
応させ、version 2.50 以降が公開されました。同氏は version 2.79 までのバ
ージョンアップを行ない、同じようにサポートを終了しました。

　これを私立花が引き継ぎ、68060 の命令に対応させるなどしたものが version
2.80 以降です(それまで作成していた version 2.78 patchlevel 5 のベースを
version 2.79 に変更したものを version 2.80 としました)。

　version 3.10 以降からは M.Suzuki 氏の協力により、FreeBSD 上でも動作す
るようになりました(Human68k 用の実行ファイルを逆アセンブルします)。


●サポートについて

　上記の通り R.ShimiZu 氏よりサポートを引き継いだので、今後は dis に対す
る要望や不具合の報告は立花宛てにお願いします。



━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	著作権及び保証の有無

────────────────────────────────────

　著作権及び保証については、K.Abe 氏は dis version 2.06β の README.DOC
に以下のように述べています。

==== ここから ====
［無保証］

  DIS は、正しく動作することを望んで作られていますが、動作の保証はいた
しません。DIS・DIS によって作られたソースプログラム・その実行ファイル・
及びこれらに準じるものによって被ったいかなる損害についても、作者は関知
いたしません。ユーザーの責任で使用して下さい。しかし本プログラムの動作
に異常/不都合が発見された場合は、作者まで連絡を下さると幸いです。でき
る限り対応したいと思います。


［著作権］

　本プログラムはフリーウェアとします。著作権は留保しますが、コピー・転
載・改造は自由です。ただしアーカイブからファイルを削除しての転載は遠慮
願います。
==== ここまで ====

　また、R.ShimiZu 氏は dis version 2.79 の README2.DOC で以下のように述
べています。

==== ここから ====
 DIS v2.06β に準ずるものとします。したがって無保証です。著作権は、大
半が安倍氏のもの、680x0化対応改造部分が私(しみずりょう)のものとして保
留されます。
 コピー・改造・転載は自由に行うことができます。
 本プログラムはフリーウェアとします。
==== ここまで ====

　dis version 2.80 以降については、GNU General Public Licence の verison
2 に従います。自由、かつ、無保証となります。

　著作権に関しては、dis version 2.06β までに記述された部分を K.Abe 氏が、
version 2.79 までで変更された部分を R.ShimiZu 氏が所有します。version
2.80 以降及び、その前身である version 2.78 patchlevel 1〜5 での変更部分
は私(立花)が著作権を所持します。また、GNU のパーサジェネレータ Bison を
使用しているので、パーサ部分は GNU の著作物でもあります。

　なお、このファイルは dis version 2.06β の README.DOC、dis version
2.79 の README2.DOC を参考にしています。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	アーカイブの内容

────────────────────────────────────

　dis の書庫には以下のファイルが含まれます。

bin/dis.x	dis 本体(Human68k 用、X680x0 全機種対応)
bin/dis030.x	〃      (Human68k 用、68020 以降専用)
		※ dis030.x は同梱されない場合があります。

src/*		dis のソースコード類
src/avl/*	AVL ライブラリのソースコード類
src/ports/*	移植用 Makefile と解説
include/*	dis 用インクルードファイル
		(これ以外のものを使っても勿論構いません)

README.DOC	このドキュメント
ChangeLog	dis の変更履歴
dis_option.1	オプションの簡易説明書
labelfile.5	ラベルファイルの仕様書
table.doc	テーブル記述ファイルに関するドキュメント
tablefile.5	テーブルファイルの仕様書
GPL.TXT		GNU GENERAL PUBLIC LICENSE Version 2


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	準備

────────────────────────────────────

　配布に実行ファイルが含まれている場合、dis をパスの通ったディレクトリに
置き、環境変数を設定するだけで使用できるようになります。実行ファイルがな
い場合は各自で make して下さい。


●インクルードファイルの設定

　dis は起動するとまず DOS/IOCS/FPACK ファンクションコールの名称を収得す
る為に各コールを定義したインクルードファイルを読み込みます。それぞれのフ
ァイルは doscall.mac/iocscall.mac/fefunc.mac に対応し、必ず存在しないと
逆アセンブルが出来ません。それらの存在するパス名を環境変数 dis_include
若しくは include に設定して下さい。dis_include の方から優先してファイル
が検索されます。

　ただし -Y オプションを指定した場合は、それらのパスに先立ってカレントデ
ィレクトリからファイルを検索します。

　また、SX-Window 対応モードで起動した場合は SX ファンクションコールの名
称を収得する為に sxcall.mac も読み込みます。ファイル名をフルパスで環境変
数 dis_sxmac に設定して下さい。

　fefunc.mac は XC ver 1 の fefunc.h に相当します。dis version 2.79 まで
は fefunc.h か、それを fefunc.dis にリネームしたものを参照していましたが、
XC ver 2 の fefunc.h では使えないなどの混乱が生じた為、fefunc.mac として
提供することにしました。dis のアーカイブに同梱されている include ディレ
クトリの fefunc.mac を前述の環境変数で指定したパスにコピーして下さい。同
ディレクトリにはその他のインクルードファイルも納めているので、必要ならそ
れらも使って下さい。

　なお、dis version 2.79 までで使っていた fefunc.h や fefunc.dis も問題
なく使えるので、リネームするなりリンクを張るなりしても結構です。


●オプションの設定

　dis は以下の環境変数を参照します(変数名は小文字です)。

dis_opt
	　デフォルトの dis のオプションを指定します。この環境変数で指定
	したオプションはコマンドラインより先に解釈されます。出力関係のオ
	プション等、常に付けるオプションを設定しておくと便利でしょう。な
	お、この環境変数で設定されたオプションは、上書き指定が可能なもの
	(-m 等)を除きコマンドラインからの取り消しは出来ません。

	　オプションの詳細については後述のオプションの項や dis_option.1
	を参照して下さい。

dis_include
include
	　doscall.mac/iocscall.mac/fefunc.mac/sxcall.mac のあるディレク
	トリのパス名を設定しておいて下さい。dis_include の方を先に見ます。

	　--include-XXX-mac=file オプションでコマンドラインから違うファ
	イルを読み込むように指定したり、--exclude-XXX-mac オプションでフ
	ァイルを読み込まず、ファンクションコールの逆アセンブルも行わない
	ようにすることが出来ます。

dis_sxmac
	　SX-Window 用のインクルードファイル(アセンブラ用)のファイル名を
	フルパスで設定しておけば -u1 オプション指定時に SX-Window の A
	line trap を SXCALL name のように出力できます。

dis_header
	　出力ファイルの最初に出力される .include 部を書いたファイルのフ
	ァイル名をフルパスで設定しておけば、そのファイルの内容がデフォル
	トの .include の代わりに挿入されます。デフォルトの出力内容は
		.include	doscall.mac
		.include	iocscall.mac
		.include	fefunc.mac
	です(ファイル名は実際に読み込んだファイルのフルパスになります)。

	　また、-u1 オプション指定時に環境変数 dis_sxmac を設定している
	場合には
		.include	$dis_sxmac
	も追加されます。

	　--header=file オプションでコマンドラインから違うファイルを読み
	込むように指定することが出来ます。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	使用法

────────────────────────────────────

　以下の通りです。出力ファイル名を省略するか、"-" を指定した場合は標準出
力に出力します。出力ファイル(ソースコード/ラベルファイル両方とも)が既に
存在すると上書きするか問合せます。

	dis [option] 実行ファイル名 [出力ファイル名]


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	オプション解説

────────────────────────────────────

　スラッシュ('/')はパスデリミタとして認識されるので、マイナス('-')しか使
用できません。大文字、小文字は区別されます。

　省略可能な引数を受け取るオプションに引数を指定する場合は、間にスペース
等を入れないで下さい。オプションの直後に文字が記述されていないと、引数が
省略されたものと見なされます。

　オプションは環境変数 dis_opt に設定しておくことも出来ます。コマンドラ
インと両方見るので、良く使うオプションを書いておくと便利かも知れません。


●命令セットに関するオプション

-m num
	　逆アセンブル対象のMPUを指定(num=68000〜68060)。

	　逆アセンブルする命令セットを選択します。-m68040〜68060 指定時
	は内蔵コプロセッサ・MMU 命令も使用可能になります。

	　-m68000,68030 のように複数の MPU を指定すると、指定した全ての
	MPU の命令セットが同時に使用可能になります。また、-m680x0 を指定
	すると選択可能な全ての MPU の命令セットが採用されます。

-m cpu32
	　CPU32 命令を有効にする。

	　CPU32 の追加命令 lpstop、tbls(n)、tblu(n) を逆アセンブル出来る
	ようにします。.cpu の切り換えは行ないません。

-m 68851
	　68851 命令を有効にする(-m68020 指定時のみ有効)。

	　外付け MMU 命令を逆アセンブル可能にします。

	　このオプションは -m680*0 オプションによってクリアされるので、
	それより後に指定して下さい。

-m 6888x[,ID]
	　有効な FPCP とその ID を指定(68881/68882 ID=[1],2-7)。

	　-m68020〜68030 を指定している場合に、外付けコプロセッサ命令を
	逆アセンブル可能にします。-m68881 と -m68882の機能は全く同じです。

	　ID の指定を省略した場合は1と見なされます。-m68881 -m68882,2 の
	ように複数のIDを指定することも出来ます。

	　このオプションは -m680*0 オプションによってクリアされるので、
	それより後に指定して下さい。

-P num
	　ソフトウェアエミュレーション命令を有効にする(ビット指定、初期
	値=3)。このオプションは将来アルファベットが足りなくなった時に違
	う機能が割り当てられる可能性があります。なるべく --(no-)fpsp、
	--(no-)isp を使用して下さい。

		+1 未実装浮動小数点命令を有効にする。
		+2 未実装整数命令を有効にする。

--(no-)fpsp
	　未実装浮動小数点命令を[有効](無効)にする。

--(no-)isp
	　未実装整数命令を[有効](無効)にする。

	　通常は、システムによってソフトウェアエミュレーションされること
	が保証されている命令は実在する命令と見なされますが、このオプショ
	ンを指定した場合は未定義命令と見なします。

--no-fpu
	　内蔵FPU命令を無効にする(-m68040〜68060の後に指定)。

--no-mmu
	　内蔵MMU命令を無効にする(-m68030〜68060の後に指定)。

	　通常は -m680*0 オプションで指定した MPU によっては、自動的に内
	蔵 FPU/MMU 命令が有効になります。これらのオプションを指定すると
	それらの命令を対象命令セットから除外します。

	　逆アセンブルするファイルにそれらの命令が含まれていないと分って
	いる場合、このオプションを指定することで命令セットを限定し、解析
	の手助けをすることが出来ます。

	　このオプションは -m680*0 オプションによってクリアされるので、
	それより後に指定して下さい。


●解析に関するオプション

-h
	　データ領域中の $4e75(rts のコード)の次のアドレスに注目する。

	　素直でないコーディングをしたプログラムの場合(!?!?)、出力ファイ
	ルにデータの塊が残る場合があります。そのような場合はユーザーがラ
	ベルファイルを用いて dis の解析の「つっかかり」を与えれば良いの
	ですが、このオプションを付けてもたいていのところを解析してくれる
	筈です。

-i
	　分岐先で未定義命令等を発見しても呼び出し側をデータ領域にしない。

	　通常は「未定義命令のあるところに飛ぶような奴は俺はプログラムと
	認めねぇ」ですが、このオプションを付けると、「そんなことは俺の知
	ったことじゃねぇ」になります(多分)。

-j
	　実行時にアドレスエラーの起こるであろう命令を未定義命令と見なさ
	ない。

	　通常は move.l $00000001,d0 等の、実行時にアドレスエラーが起こ
	るであろう命令は未定義命令と見なしますが、このオプションを付ける
	とそのチェックをしません。なお、68020 以降の MPU では上に挙げた
	命令はアドレスエラーになりませんが、dis では未定義命令と見なしま
	す。普通のプログラムなら、効率的なメモリアクセスの為に偶数アドレ
	スに整合しているので問題ないと思います。

-k
	　命令の中を指すラベルはないものと見なす。

	　命令の中を指すラベルの存在しないプログラムで、このオプションを
	指定すると生成ファイルの質が良くなる場合があります。しかし存在す
	るプログラムで指定すると生成ファイルの質がかなり悪くなります。

	　このオプションを付けると、label+$?????? と言うラベルを全て解消
	するために、label+$?????? の含まれる領域はデータ領域とされます。
	例えば、

	top:	bsr	label3
		lea.l	(label1),a0
		move.w	(label2),d0
		rts
	label1:	.dc.w	$0040	;data
	label2:	.dc.w	$0000	;data
	label3:	.............	;program

	　上のプログラムは -k オプション無しだと
	top:	bsr	label3
		lea.l	(label1),a0
		move.w	(label1+$000002),d0
		rts
	label1:	ori.w	#$0000,d0
	label3:	.............

	　-k オプションを付けると
	top:	bsr	label3
		lea.l	(label1),a0
		move.w	(label2),d0
		rts
	label1:	.dc.b	$00,$40
	label2:	.dc.w	$0000
	label3:	.............

	　とりあえず、-k オプションを付けずにソースジェネレートしてみて
	おかしいところがあれば、-k オプションを付けてやってみて、２つを
	比較してみると良いでしょう。

-f
	　バイト操作命令の不定バイトのチェックをしない。

	　前述の不定バイトチェック(不定バイトが $00 か $ff かどうかのチ
	ェック)をしないようにします。

	　このオプションを付けた場合、生成ファイルをアセンブルしたものが
	元の実行ファイルと等しくならない場合があります。

-E
	　バイト操作命令の不定バイトの書き換えチェックをしない。

	　不定バイトに対するラベルが存在した場合、通常は、「不定バイトを
	書き換えるような奴はいないよなぁ」と信じてその命令(不定バイトの
	ある)領域をデータ領域にしてしまいますが、-E オプションはこのチェ
	ックをしないようにします。

-u[num]
	　A line trap 及び DOS call、浮動小数点演算ドライバ(FLOATn.X)で
	使用されていない F line trap を未定義命令と見なさない。

	　Mac Emulator や、SX-Window 等の A line trap を使ったプログラム
	をソースジェネレートするときに付けて下さい。

	　なお、使用されているかどうかの判断は、doscall.mac、fefunc.mac
	にシンボルが存在するかどうかによります。

	　-u1 の時、SX-Window 対応となります。環境変数 dis_sxmac をセッ
	トしておけば、SX-Window のファンクションコールを、SXCALL name の
	ような形で出力します。

-y
	　「text セクション中の全てのデータ領域をとりあえず逆アセンブル
	してみて、おかしくなければそこをプログラム領域と思い込む」ことを
	しない。

	　dis のデフォルトでは、一通り解析した後、サイズの分からないデー
	タは「プログラムちゃうか？」と疑って、片っ端から解析しようと試み
	ます。-y オプションを付けると、「片っ端から」ではなく、データの
	終わりがリターン命令、ジャンプ命令等と見受けられるもののみを「プ
	ログラムちゃうか？」と疑います。

	　このオプションをつけると解析の対象となる領域が少なくなる分だけ、
	解析時間が減ります。しかしプログラム領域をデータ領域として残して
	しまうことが多くなるでしょう。しかし付けないと、データ領域をプロ
	グラム領域としてしまうこともあるかも知れません。

-n num
	　文字列として判定する最小の長さ(デフォルトは3)。

	　このプログラムでは、文字列領域を自動的に判別します。ただ、文字
	列判別を完璧に行うのは不可能で、文字列でないところも文字列として
	しまう場合があります(特に短い文字列)。このオプションを指定すると、
	それ未満の長さは文字列として判定しません。また、num に 0 を指定
	すると、文字列の自動判別を行いません。

-D
	　データセクション中にもプログラムを認める。

	　dicm.x など、データセクションに分岐するプログラムが存在するこ
	とが分かったためにサポートしました。データセクションに分岐してい
	れば、"解析中のバックトラックの要因の表示機能" で、"pc が有効な
	セクションをを外れた" と表示されるのでわかると思います(他の理由
	でもそう表示されることはありますが)。プログラム領域解析中に "pc
	が有効な...." と表示されたらこのオプションを試してみて下さい。

-R num
	　未使用フィールドのチェック項目の指定(ビット指定, 初期値=15)。

		+1 mulu.l、muls.l、ftst.x における未使用レジスタフィール
		   ドのチェック。
		+2 拡張アドレッシングでのサプレスされたレジスタフィール
		   ドのチェック。
		+4 サプレスされたインデックスレジスタに対するスケーリン
		   グのチェック。
		+8 サプレスされたインデックスレジスタに対するサイズ指定
		   (.l)のチェック。

-G
	　サブルーチンコール命令の直後に引数を置くプログラムを解析する。

	　ROMDB などサブルーチンコール命令の直後に引数を置く古い手法が使
	われているプログラムの場合、dis は命令とデータの区別を自動的にす
	ることは出来ない為に、その一帯を全てデータ領域にしてしまいます。
	このオプションを指定すると、jsr、bsr などサブルーチンコール命令
	の直後にデータラベルがあった場合、その時点でプログラムの解析を打
	ち切り、正しいプログラムと認めます。自動的にデータラベルが登録さ
	れることはないので、ユーザによるラベルファイルの修正が必須となり
	ます。

	　ラベルファイルを読み込まない初回の逆アセンブル時は -G オプショ
	ンは指定しないで下さい。正しく解析が行われない可能性があります。

	・ラベルファイルの修正方法

	　まず一度 -e オプションを指定して逆アセンブルし、ラベルファイル
	を作成します(この時 -G オプションは指定しないこと)。次に、不完全
	なソースコードを自分で解析しながら、サブルーチンコール命令の直後
	にある引数を探します。そのデータのアドレスを計算し、ラベルファイ
	ルに追加します。

	　今度は -g、-G オプションを指定して逆アセンブルします。ラベルフ
	ァイルの指定が正しければ、追加したアドレスの直前までがプログラム
	として、追加したアドレス以降がデータとして解析される筈です。


●ファンクションコールに関するオプション

--exclude-doscall-mac
--exclude-iocscall-mac
--exclude-fefunc-mac
	　それぞれ DOS コール、IOCS コール、FEFUNC コールを認識しないよ
	うにします。DOS/FEFUNC コールは全て未定義命令か .dc 疑似命令(-u
	指定時)に、IOCS コールは moveq + trap #15 で出力されます。

	　このオプションは X680x0/Human68k 以外の環境の実行ファイルを逆
	アセンブルする時に、余計な解釈を行わないようにする為に使用します。

--include-doscall-mac=file
--include-iocscall-mac=file
--include-fefunc-mac=file
	　それぞれ DOS コール、IOCS コール、FEFUNC コールのマクロ/ファン
	クションコール番号を定義したファイルを指定します。file にファイ
	ル名を記述して下さい。無指定時は環境変数 dis_include か include
	で指定したディレクトリにあるファイルが読み込まれます。

	　このオプションは環境変数 dis_include、include よりも優先されま
	す。


●出力ファイルに関するオプション

-b num
	　分岐命令のサイズを以下のようにする(分岐命令のサイズとは Bcc 等
	の .s/.w.l のことです)。

		-b0 ショートブランチで済むのにワードブランチをしている、
		    またはワードブランチで済むのみロングワードブランチを
		    している場合(デフォルト)。
		-b1 サイズを常に省略します。
		-b2 サイズを常に付けます。

-o num
	　文字列領域の桁数(デフォルトは 60)。

	　ソースファイルに出力する文字列領域の桁数を指定します。

-w num
	　データ領域の横バイト数(デフォルトは8)。

	　データ領域の横バイト数を指定します。デフォルトでは
		.dc.b	$??,$??,$??,$??,$??,$??,$??,$??
	のように横は8バイトです。データの多いプログラムでは16にした方が
	良いかも知れません。

-a[num]
	　num 行ごとにアドレスをコメントで出力。

	　num を省略すると５行ごと。ラベルファイル(後述)を編集する時等は
	便利かも知れません。

-r
	　文字列に16進数のコメントを付ける。

-x
	　オペコードに16進数のコメントを付ける。

	(例)
		ori.b	#xx,d0		;$0000,$00xx
		rts			;$4e75
	のようになります。

-s[num]
	　外部定義シンボルについて、定数の定義行及びアドレス値の外部宣言
	行を出力する。

	　実行ファイルにシンボルテーブルが付属している場合、シンボル名と
	アドレス値または定数が得られます。これらの情報は再アセンブルの再
	にはなくても問題ありませんが、シンボルテーブルまで再現するには外
	部定義しなければなりません。アドレス値についてはラベルを "::" で
	定義するのでシンボルテーブルに出力されますが、定数は .equ 疑似命
	令で定義しなければなりません。このオプションは定数を定義するかを
	指定します。

	　また、アドレス値はラベル定義時に同時に外部定義されるのですが、
	シンボルテーブルに現われる順番と、実際にソースコードに現われる順
	番が違うとシンボルテーブルが一致しません。そのような場合、シンボ
	ルテーブルに現われる順番通りに .xref 疑似命令でラベルを宣言する
	と順番まで再現されます。このオプションでは宣言を行うかどうかも指
	定できます。

	　定数の定義は「name:: .equ 値」、ラベルの宣言は「 .xref name」
	という形式でソースコードの先頭部分に出力されます。なお、'*'＋フ
	ァイル名＋'*' という形式のアドレス境界情報のシンボルはアセンブラ
	で扱う事が出来ないので、常に無視されます。

	数値を省略した場合は -s0 と見なします。標準設定は -s1 です。

	-s0	外部定義シンボルの定義行を出力しません。
		ただし、アドレス値については各セクションで定義される時に
		外部定義されるので、-C0 や -C1 オプションを指定しない限
		り常に外部定義になります。

	-s1	定数のみ定義行を出力します。定数の外部定義シンボルについ
		ては、定義される順番も含めてシンボルテーブルが再現されま
		す。

	-s2	アドレス値についても、.xdef 疑似命令による外部定義を出力
		します。全てのシンボルについて、定義される順番も含めてシ
		ンボルテーブルがほぼ完全に再現されます。

		ただし、スタックセクション(属性 0x0204)及びコモンセクシ
		ョンのシンボル(同 0x0003)は再現できず、BSS のシンボル(同
		0x0203)となってしまいます。

	　-e オプションで出力されたラベルファイルのシンボル名を書き換え
	て -g オプションで読み込ませる場合は、-s2 は指定しないで下さい。
	.xdef で宣言されるシンボル名は実行ファイルに付属するシンボルテー
	ブルそのままであるのに対し、ソース中で定義/参照されるのはラベル
	ファイルで変更されたシンボル名なので、アセンブルしようとするとエ
	ラーになってしまいます。

-F
	　dbra、fdbra を dbf、fdbf として出力する。

-X
	　16進数を大文字化する。

-U
	　オペコード等を大文字化する。

-Z[num]
	　16進数をゼロサプレスする。

		-Z0	普通にゼロサプレスする。
		-Z1	ゼロサプレスした時省略可能な '$' を省略する。

	　num を省略した場合は -Z0 と同じになります。

-N
	　デフォルトのサイズならサイズを出力しない。

	(例)
		move.w	#$1234,d0 (default)
		↓
		move	#$1234,d0

-K char
	　コメントキャラクタを変更。

	　コメントの先頭には通常 ';' がつきますが、それを変更出来ます。'#'
	にしたければ、-K# と指定して下さい。

-L char
	　ラベルの先頭文字を変更。

	　ラベルの先頭には通常 'L' がつきますが、それを変更出来ます。'_'
	にしたければ、-L_ と指定して下さい。

-C
	　ラベルの後のコロン(:)を出力するかどうか。

		-C0 ラベルの後にコロンを付けない。
		-C1 ラベルの後にコロンを1つ付ける。
		-C2 ローカルラベルにはコロンを1つ、外部定義ラベルにはコ
		    ロンを2つ付ける(デフォルト)。
		-C3 すべてのラベルの後にコロンを2つ付ける。

-A
	　cmpi、movea 等を cmp、move 等にする。

	　ただし、演算先がデータレジスタの cmpi、ori、andi、subi、addi、
	eori は "i" なしの命令とオブジェクトコードが異なるので、そのまま
	で出力されます。また、addi と subi で即値が 1 〜 8 の場合、addq
	や subq に最適化されるのを防ぐ為、即値にサイズが付きます。

-S[num]
	　出力ファイルを分割して出力する。

	　実行ファイルの(ほぼ)num KByte ごとに出力ファイルを分割します。
	数100 KByte の実行ファイルをソースジェネレートする時に付けると、
	あとから見易いかも知れません(そのままではアセンブル出来ませんが)。

	　分割されたファイル名は以下のようになります。
		text section は、拡張子が以下のようになります。
		  .000 .001 ..... .009 .00a .00f .010 .....

		data section、bss は拡張子がそれぞれ
		.dat .bss になります。

	　num を省略すると 64KByte ごとに分割します。ファイルの分割は空
	行で行われるので、サブルーチンの途中で切れたりと言うことはそんな
	には無いと思います。

-B
	　bra の後でも改行する。

	　デフォルトでは、rts、rte、rtr、jmp、DOS _EXIT、DOS _EXIT2、DOS
	_KEEPPR、SXCALL ExitToShell の後で一行空行を入れますが、このオプ
	ションをつけると bra の後でも空行を入れるようになります。

-M
	　cmpi、move、addi.b、subi.b #imm および pack、unpk にコメントを
	付ける。

	　num が表示可能な ASCII code の場合に以下のようなコメントを入れ
	ます。解析には便利でしょう。

		cmp.b #$40,d0	;'@'

-W num
	　同一データを .dcb で出力する最小バイト数。0なら圧縮しない(初期
	値=64)。

	　データを .dc.? で出力する場合、全てのデータが同一の値であれば
	.dcb.? により圧縮して出力されますが、一定のサイズより小さい領域
	は例え同一値であっても圧縮されません。このオプションでそのサイズ
	の閾値を変更出来ます。

--a7
	　a7 レジスタを'a7'と表記する(デフォルト)。

	　--sp オプションを取り消します。

--sp
	　a7 レジスタを'sp'と表記する。

	　通常、スタックポインタは'a7'と表記されますが、このオプションを
	指定すると'sp'と表記されるようになります。

--new-syntax
	　アドレッシングを新表記で出力する。

	　--old-syntaxを打ち消します。

--old-syntax
	　アドレッシングを旧表記で出力する(標準では--new-syntax)。

	　通常は 68020 以降で定められたアドレッシング表記で出力しますが、
	このオプションを指定した場合は 68000 の表記で出力します。ただし、
	68020 以降でしか使用できないアドレッシングでは常に新しい表記で出
	力します。

--(in)real
	　浮動小数点を[実数表記](内部表現)で出力する。

	　命令のオペランドやデータとして浮動小数点を出力する場合の表記を
	選択します。--real を指定すると「0f1.23e+10」といった実数表記、
	--inreal を指定すると「!4048f5c3」といった内部表現で出力します。

	　非数や無限大、非正規化数、未使用ビットがセットされているデータ
	の場合は実数表記が不可能なので常に内部表現で出力されます。

	　標準状態では --real が指定されています。

--overwrite
	　ファイルを無条件で上書きする。

	　通常、指定した出力ファイルが既に存在した場合、上書きするかどう
	かを問い合わせますが、このオプションを指定すると問い合わせせずに
	強制的に上書きします。

--header=file
	　出力ファイルの最初に出力される .include 部を書いたファイルを
	file に指定すると、そのファイルの内容がデフォルトの .include の
	代わりに挿入されます。環境変数 dis_header より優先されます。


●実行ファイルに関するオプション

-d
	　デバイスドライバの時に指定。

	　実行ファイルがデバイスドライバの時は必ず指定して下さい。ほんの
	僅かに生成ファイルの質が良くなります。デバイスドライバでないとき
	は指定しないで下さい。妙なことが起こるかもしれません。

-z base,exec
	　指定した実行ファイルを単なるバイナリファイルと見なす。その際、
	そのファイルは base から読み込まれて exec から実行されるものとす
	る。base、exec は16進数のみ。

	　例えば、2HD disk の IPL 部を読み出して解析するのなら、 
		dis 2hdipl 2hdipl.s -z2000,2000
	等と指定する。ROM の IPL/IOCS を解析するのなら、
		dis rom rom.s -zff0000,ff0010
	等と指定する(-h をつけた方が良いかも知れない)。

	(当然 IPL 等は db.x 等で Human68k のファイルに落としておかねばな
	りません)

	　少なくとも base は分かっていなければなりません。exec が分から
	なければ base と同じにしておいて、-h オプション等を付ければなん
	とか見れるソースになると思います。


●ラベルファイルに関するオプション

-e[filename]
	　ラベルファイルの出力。

	　ファイル名を指定しなければ、出力ファイルの拡張子を .lab に変更
	した名称のファイルを作る。

-g[filename]
	　ラベルファイルの読み込み。

	　ファイル名を指定しなければ、出力ファイルの拡張子を .lab に変更
	した名称のファイルを読み込む。


●テーブル記述ファイルに関するオプション

-T[filename]
	　テーブル記述ファイルの読み込み。

	　ファイル名を指定しなければ、出力ファイルの拡張子を .tab に変更
	した名称のファイルを読み込む。


●その他のオプション

-q[num]
	　解析中/出力中のメッセージ( ><?#s!*.-+rRzt$ )を出力しない。

		-q0 通常の出力抑制。
		-q1 テーブルに関する情報も出力しない。

	　数値を省略した場合は -q0 と同じ。

	　出力しないとかなり速くなるので、大きいファイルをソースジェネレ
	ートする時はなるべく付けましょう。

		-- 文字の説明 --
		> 分岐命令等で、解析の深さが深くなった。
		< リターン命令等で、解析の深さが浅くなった。
		? 未定義命令等を発見して、解析の深さが浅くなった。
		# データ。
		s 文字列。
		! ラベルチェックで、命令の中のラベルを発見した。
		* ラベルチェックで、命令の中のラベルを解消した。
		。ラベル１つ。
		- そのままではプログラム領域からデータ領域に突入してしま
		  う所を発見/修正した。
		+ ラベルチェックでプログラム領域中に未定義命令等を発見し
		  た。
		r リラティブオフセットテーブル。
		R リラティブオフセットテーブル(ロングワード)。
		z ロングワードテーブル。
		t ユーザー指定のテーブル。
		$ BSS ラベル１つ。

-v
	　単なる逆アセンブルリストを出力する。

	　このオプションはおまけです。db.x の出力をリダイレクトするより
	は見易いかな…

-V num
	　解析中のバックトラックの要因の表示。

		-V0 出力しない(version 1.13 以前と同じ)。
		-V1 プログラム領域の筈のところでのバックトラックの要因を
		    表示(デフォルト)。
		-V2 全ての領域でのバックトラックの要因を表示。

	　表示されるのは、dis がプログラムと認めなかった理由、およびその
	アドレス等です。作者にしか意味が分からないかも知れません(^_^;)

-I
	　ラベルチェック中に、修正したアドレスを表示する。

		命令の中を差すラベル(X -> Y+?)

		　アドレス X が命令の中にあってラベルを振ることができ
		ないために、Y+? にするという意味。

		命令の中を差すラベル(X)データ領域に変更しました(Y-X)

		　-k オプションを使用している、あるいはアドレス X が不定
		バイトの上にあるために、Y から X までをデータ領域に変更
		したという意味。この領域が本当にプログラムのようであれば
		-E オプションを試してみると良いかもしれない。

-Y
	　カレントディレクトリからも include ファイルを検索する。

		通常は環境変数 dis_include や include で指定されたパスに
		あるインクルードファイルを読み込みますが、このオプション
		を指定するとカレントディレクトリにあるファイルを優先して
		読み込みます。カレントになければ環境変数で指定されたパス
		を検索します。


●無用なオプション(バグがあったりして)

-c
	　ラベルチェックを行わない。

	　ラベルチェックとは主に「命令の中を指すラベルを捜す」作業です。
	-c オプションを付けると、この作業を行いません。付ける必要はあり
	ません。付けると命令の中を指すラベルが存在する場合、正常なソース
	が出力されない場合があります。

-l
	　プログラム領域が見つからなくなるまで何度も捜すことをしない。

	　このプログラムではデータ領域からプログラム領域が見つからなくな
	るまで捜しますが、-l オプションをつけると一度しか捜しません。付
	ける必要はありません。

-p
	　データ領域中のプログラム領域を判別しない。

	　一通り解析してプログラム領域とデータ(と思われる)領域に分けます
	が、データ(と思われる)領域の中にもプログラム領域がたいてい埋もれ
	ています。-p オプションを付けると、データ(と思われる)領域からプ
	ログラム領域を捜しません。付ける必要はまずありません。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	テーブル記述ファイルについて

────────────────────────────────────

　dis はリラティブオフセットテーブルを除き、自動ではテーブルを認識するこ
とは出来ません。そこで、テーブルの形をユーザーが記述して dis に教えてや
ろうというのがテーブル記述ファイルです。詳細は tablefile.5  及び
table.doc を参照して下さい(後者には間違いがいくつかあります)。

　dis version 2.83 以降では、限定的ながらもテーブルで浮動小数点を出力で
きます。使用できるのは以下の識別子です。

	dc.s (.dc.s)
	dc.d (.dc.d)
	dc.x (.dc.x)
	dc.p (.dc.p)

　dc.?[ 式 ] という形式も可能ですが、オペランド表現式は一切指定できませ
ん。これらの命令は単に pc のデータを出力します。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	ラベルファイルについて

────────────────────────────────────

　ラベルファイルは、各ラベル(=アドレス)の属性、シンボルネームを示すもの
で、-e オプションで出力させることが出来ます。ラベルファイルを書き換えて、
次に -g オプションで、書き換えたラベルファイルを読み込ませることによって
ラベルファイルに従ったソースファイルを生成することが出来ます。

　なお、ラベルの属性を変える、ラベルを増やすのは構いませんが、減らすと正
常なソースが出来ないと思います。そのラベルはどこかで参照されていると思わ
れるからです。

　ラベルファイルを妙な風に書き換えると、dis の動作が変になるかも知れませ
ん。ご注意下さい。

　ラベルファイルのファイル名は -e/-g オプションの後に特に指定しなければ、
実行ファイル名の拡張子を .lab に変えたものになります。-e/-g オプションは
同時に使用出来ます。

　ラベルファイルの書式については labelfile.5 を参照して下さい。


●備考

　D の後に F という文字が付く場合があります。これは「絶対」を意味してい
て、D?F なら「絶対にデータ」ということです。つまり、そこから解析してみて
プログラムと見なし得なかったことを示します。

　ユーザーが書き加える/書き変える属性文字列で、「絶対にデータ」と言うの
なら f を書いて下さい。f を書かないと、DIS はそこから「プログラムちゃう
か？」と思ってしまうかも知れません。反対に単なる解析のつっかかりを与える
のであれば、du のみ書いて下さい。dis はそこから「プログラムちゃうか？」
と疑って調べてくれます。dis の出力した F は別に消しても問題ない筈です。

　(重要)dis が出力する属性文字列は大文字ですが、ユーザーの書き加える属性
文字列は全て小文字でなければなりません。小文字にしないと、例えば P の場
合、そのアドレスからは解析済みと見なしてしまいます。小文字にするとそこか
ら解析するので、うまくいきます。 D の場合も同様です。

　属性文字列の DZ は、.z ファイルや IOCS ROM 等でロングワードのテーブル
をユーザーが指定するためにあります(.x ファイルではロングワードのテーブル
は自動的に認識します)。後の "IOCS ROM をソースジェネレートする方法" を参
考にして下さい。(注)この機能はテーブル記述ファイルで代用出来ます。

　ラベルファイル中のシンボル名を変更すれば、出力ソースの中でも変更されま
す。シンボル名を新たに書き加えれば、そのアドレスは全てシンボル名に置換さ
れます。シンボル名の最初が * ならばコメントと見なされてシンボル名にはな
りません。

　C で doslib や iocslib 等を使うと、シンボルテーブルが残っていた場合、
doscall.mac や iocscall.mac に定義されているのと同名のラベルが出てくると
きがよくあります(アセンブルすると redifinition error がでる)。そういうと
きはラベルファイルを出力して、同名のラベルを適当な違うラベル名に書き換え
れば良い筈です。


●リラティブオフセットテーブル

　リロケータブルなプログラムでテーブルを作る時に良く用いられます。テーブ
ルにはテーブルの先頭番地からのオフセットが符号付１ワードで書かれます。分
岐テーブルに良く用いられますが、データテーブルにももちろん使用可能です。
gcc がテーブルを作るときは大抵このようになっているようです。

(例)
	add.w	d0,d0			;*2
	move.w	(table,pc,d0.w),d0
	jmp	(table,pc,d0.w)
table:
	.dc.w	label1-table
	.dc.w	label2-table
	.dc.w	label3-table
	.dc.w	label4-table

　DIS は大抵のリラティブオフセットテーブルを自動的に認識しますが、少し手
を抜いているので、認識しなければラベルファイルを書き変えなければならない
場合があるでしょう。データテーブルに使用した場合は自動的には全く認識でき
ません。


● IOCS ROM をソースジェネレートする方法

　まず、db.x で IOCS ROM のイメージファイルを作ります(ROM は 87年05月07
日 version を基にしています)。

	db.x
	-wromimage,ff0000 ffdcff	#この ffdcff はかなりいい加減
	-q

　とりあえず、ソースジェネレートします。

	dis romimage rom.s -zff0000,ff0010 -e -h -q

　IOCS ROM の中の IOCS call のテーブルを dis に認識させるため、
romimage.lab を書き変えます。

	ff1b32	DUF -> ff1b32  dzf	#この f はいまのところ意味が無い

　また、次のところをプログラムと見なしてしまうので、そこも書き変えます。
ff05ca が P でなければ書き変える必要はありません。

	ff05ca	P   -> ff05ca  duf	#この f は絶対必要

　もういちどソースジェネレートします(-e は付けなくても良い)。

	dis romimage rom.s -zff0000,ff0010 -g -e -h -q

　これで rom.s が出来ました。dis で簡単に出来るのはここまででしょう。-e
オプションを付けていれば、ラベルファイルが更新されている筈ですので、そこ
からまたラベルファイルに変更を加えてソースジェネレートすることも出来ます。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	プログラムの解析について

────────────────────────────────────

●未使用レジスタフィールド

	mulu.l <ea>,Dn
	muls.l <ea>,Dn
	ftst.x FPn

　これらの命令コードには、レジスタを指定する為のフィールドが二つあるので
すが、片方のみ使用して、もう片方は未使用となっています。

　mulu.l <ea>,Dn の第二ワードは下のようなコードです。

	0???000000000???
	  |	      |
	  |	      +--- 未使用
	  +--------------- レジスタ番号(Dn)

　この未使用なフィールド(本来レジスタペア用のもの)は、巷のアセンブラでは
レジスタ番号と同じ数値が入るようです。例えば、mulu.l <ea>,d5 ならば、第
二ワードは、
	0101000000000101
	 ~~~         ~~~
となるようです。

　ftst.x FPn の第二ワードは

	000???_???0111010
	    |   |
	    |   +--------- 未使用
	    +------------- レジスタ番号(FPn)

　こちらの未使用フィールドは has や fas,db などでは 0 が入るようですが、
libc のライブラリの中には何故かレジスタ番号と同じ数値が入ったものもある
ようです。結局、例えば ftst.x fp5 の第二ワードは、
	000101_0000111010	(has,fas,db)
	   ~~~ ~~~
もしくは、
	000101_1010111010	(??? libc のライブラリ内に見られる)
	   ~~~ ~~~
となります。

　これらより、(素直に)アセンブルされたこれらのコードの未使用レジスタフィ
ールドは
	・もう片方のレジスタフィールドと同じ値
	・0
の、どちらかであると思われます。

　さて、この未定義レジスタフィールドを上の2つのどちらかであろうと決めつ
け、それ以外であれば未定義命令としてしまえば、データ領域とプログラム領域
の判別に役立ちます。そのためのオプションが -R オプションです。

　-R に続く数値の第0 bit が1ならば、mul[us].l <ea>,Dn / ftst.x FPn につ
いて上記のようなチェックを行い、おかしければデータ領域と見なします。


●サプレスされたレジスタ

　拡張アドレッシングは、ベースディスプレースメント、アウタディスプレース
メント、ベースレジスタ、インデックスレジスタを任意にサプレス(省略)するこ
とが出来ます サプレスされたレジスタについては、レジスタ名の前に'z'を付け
ることで表現します。

例:	asm	move.l	([label1],label2),([label3,a1],label4)
	dis→	move.l	([label1,za0,zd0.w],label2),([label3,a1,zd0.w],label4)

	asm	move.l	(d0.l),d1
	dis→	move.l	(za0,d0.l),d1

　ここでも、素直にアセンブルされたコードは、サプレスされたレジスタ番号に
0以外を指定したり、スケーリングやロングワードサイズの指定をしたりするこ
とはないであろうという経験的憶測のもとに、-R スイッチでそれについてのチ
ェックの有無を指定できます。

　-R に続く数値の、

　第1 bit が1ならば、サプレスされたレジスタ番号が 0 以外な場合、未定義命
令としてデータ領域と見なします。

　第2 bit が1ならば、サプレスされたインデックスレジスタに対してスケーリ
ングが指定されている場合、未定義命令と見なします。

　第3 bit が1ならば、サプレスされたインデックスレジスタに対するサイズ指
定がロングワード(.l)ならば、未定義命令と見なします。

　これらの3つが指定された場合は、サプレスされたインデックスレジスタは表
記そのものを省略して出力します。まとめると以下のようになります。

・-R 14  (2+4+8=14) な場合

	命令 code		命令の解釈		dis の出力

([label1,za0,zd0.w],label2)	有効		([label1,za0],label2)
([label1,za0,zd0.w*2],label2)	無効(scaling)	データ領域として出力
([label1,za0,zd0.l],label2)	無効(size)	データ領域として出力

　このようにインデックスレジスタは表記が省略されます。

・どれも指定しなかった場合

([label1,za0,zd0.w],label2)	有効		([label1,za0,zd0.w],label2)
([label1,za0,zd0.w*2],label2)	有効		([label1,za0,zd0.w*2],label2)
([label1,za0,zd0.l],label2)	有効		([label1,za0,zd0.l],label2)

　このよーなひねくれた(^^;)表現で出力します。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	備考

────────────────────────────────────

● dis の生成したソースファイルに関して

　dis の生成したソースファイルの著作権は、元の実行ファイルの著作者にある
と思われるので取り扱いには十分注意して下さい。


●忠実度

　アセンブルしてリンクした後、fc で比べてみることをお勧めします。シンボ
ルテーブルが残っていない限り違いはない筈です(dis はシンボルテーブルは完
全には再現出来ません)。また、ソースコードデバッガ情報は全く再現出来ませ
ん。上記以外で違いがあれば、それは dis のバグです。作者に報告して下さい。


●バインドファイルについて

　実行ファイルがバインドされている場合、警告を出力して終了します。ソース
ジェネレートするためには unbind でバインドファイルを展開して下さい。


●スタックオーバーフロー

　dis は関数の再帰呼び出しを多用した解析処理を行いますが、その途中でスタ
ックが足りなくなった場合は「libc: stack overflow.」と表示して強制終了し
ます。オプションに -+-s:524288 などとやってみて下さい(デフォルトは 256
KB です)。


●特殊な状況

　素直にプログラムとして認識できない実行ファイルの場合、「xxxxxx : PC が
有効なセクションを外れた」というメッセージが繰り返し表示されて先に進まな
いように見えることがあります。そのような場合でも、無限ループにはなってい
ない筈なので、しばらくの間待ってみて下さい。dis が気の済むまで出力した後、
正常に終了すると思います。

　もし長時間待ってみても終了しないようなら、それは dis の不具合です。サ
ポート担当者に報告して下さい。


●浮動小数点

　拡張精度浮動小数点を実数表記で出力する場合は、大量の浮動小数点演算を行
っているので非常に処理時間が掛かります。演算は常にソフトウェアでエミュレ
ートしているので、FPU を使用できる環境であってもあまり速くはなりません。

　処理の遅さに我慢できないようであれば、--inreal オプションを指定して全
て内部表記で出力するようにして下さい。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	仕様(メモとも言う)

────────────────────────────────────

●対応プロセッサ

	68000/68008/68010/68020/68030/68040/68060
	68881/68882
	68040 内蔵 FPU
	68060 内蔵 FPU
	68851
	68030 内蔵 MMU
	68040 内蔵 MMU
	68060 内蔵 MMU
	040FPSP
	060ISP/060FPSP
	CPU32

	※-m68008 指定時は -m68000 が指定されたものとして扱われます。ま
	  た、Target MPU に表示されることはありません。-mcpu32 は CPU32
	  の追加命令を認識するだけで、アドレッシングモード等は -m680*0
	  の指定が採用されます。こちらも Target MPU には表示されません。


●実行形式の判別

　指定されたファイルがどの種類の実行ファイルかの判別は以下の順で行われる。

	1) -z オプション指定時			Ｒ形式
	2) *.r					〃
	3) ファイルの先頭 2 バイトが 'HU'	Ｘ形式
	4) 〃			     0x601a	Ｚ形式
	5) 上記条件に一致しない			エラー


●参照されないラベル

　全く参照されないラベルが出力される場合がありますが、気にしないで下さい。

　C コンパイラの出力で、

	static char ary[100];
	int index, a = ary[ index - 10 ];

などの時、gcc などは

	lea.l	(_ary-10),a0
	move.b	(a0,d0.l),d0	;d0 = index;
	ext.w	d0
	ext.l	d0

のようなコードを出力しますが、dis はそんなことは知らずに、_ary-10 がどこ
にあろうとそこにラベルを振ろうとします。たまたま _ary-10 がプログラムの
途中だったりすると、命令の中を指すラベルのように見えます。このとき -k オ
プション等を指定しているとそこがデータの塊になったりします。-k オプショ
ンを用いる時は、なるべく -k オプションなしで出力したファイルと比較して、
ユーザーが適宜選択するようにして下さい。

　また、gcc でコンパイルされたものはデータとプログラムが入り混じっている
ので、データをプログラムと誤認することがしばしばあります。


●dis の限界

　データ領域がたまたまプログラム領域としても認識できる値の場合、周辺を巻
き込んでプログラム領域にしてしまうことがあります。具体的には

	lea	(crlf,pc),a0
	bsr	foo
	rts
crlf:	.dc.b	13,10
	.even
foo:
	nop
	rts

というコードを

L000000:
	lea	(L000008,pc),a0
	bsr	L000008+2
	rts

L000008:
	movep	($4e71,a2),d6
	rts

と逆アセンブルしてしまいます。この時、foo は命令の中を指すラベルとして
crlf+2 に置換されています。これは、「crlf がデータで foo がプログラム」
なのか「crlf がプログラムで foo は命令中を指すラベル」なのか dis には判
別できない為に起こります。これもまた dis の限界ですが、この場合はラベル
ファイルで

000008	dsf
00000a	pf

と指定すれば期待通りに逆アセンブルされます。


●ワードサイズの再配置情報

　実行ファイルの再配置情報は普通ロングワード単位での処理を行いますが、実
はワード単位で処理を行う形式も用意されています。しかし、dis はそのような
ワード単位の再配置情報には対応していません。一応通常のロングワードサイズ
のそれと同じように解釈し、また、最悪の場合でもアドレスエラーにはならない
ようにはしています。現在のところワード単位の再配置情報を処理できるのは
Human68k の DOS _EXEC ファンクションコールのコードだけで、アセンブラやリ
ンカに対応しているものがないので、dis が対応していなくても特に問題はない
と思います。


●その他の細かい仕様

　解析中の文字列の表示は標準エラー出力へ出力されています。-q option を指
定すると処理が速くなります。テーブルを多用している場合は -q1 を指定しま
しょう。

　以下のファンクションコールがリターンしないと言うことは(gcc でいう関数
の volatile 宣言...)Hard Coding してあります。
	DOS	EXIT
	DOS	EXIT2
	DOS	KEEPPR
	SXCALL	ExitToShell

　64ビット整数(.q)は倍精度実数の内部表現と同じ形式で出力されます。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	用語解説

────────────────────────────────────

実行ファイル
	　アセンブラソースを生成しようとしているファイルで、.x、.r、.z
	形式実行ファイル、単なるバイナリファイルのいずれか。

命令の中を指すラベル
	　dis がサポートしている命令の中を指すラベルとは、下のようなもの
	です。高速化や省メモリを狙ったプログラムや手抜きプログラム等で用
	いられる手法です(プログラムが分りにくくなるので、そのようなコー
	ディングは勧めません)。

	label:
		move.w	#$0000,d0
		.................
		move.w	d1,(label+$000002)

	　この場合、dis は下のようなソースを出力します。

	L??????:
		move.w	#$0000,d0
		.................
		move.w	d1,(L??????+2)

	　少し違いますが、as.x の中では、命令のイミディエイトオペランド
	の中へジャンプすると言うテクニックが使われていて、その場合も命
	令の中を指すラベルが生成されます。

不定バイト
	　オペレーションサイズがバイト(.b)の命令で、かつソースオペランド
	がイミディエイトデータの場合、命令の第３バイトは定義されていませ
	ん(不定バイト)。しかし、as.x を使っている限りこの第３バイトは
	$00 か $ff のどちらかのようなので、通常 dis はここをチェックして
	$00 か $ff のどちらでもなければ未定義命令にしてしまいます。 as.x
	では、ソース中でイミディエイトデータを正として扱っているなら不定
	バイトは $00、負なら $ff になるようです。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	謝辞

────────────────────────────────────

　dis を生み出だした K.Abe 氏と、それを成長させた R.ShimiZu 氏に感謝しま
す。

　無限ループのバグを報告し、確実に再現する方法(重要)を提供して下さった
Schmidt 氏に感謝します。

　bf 命令のエンバグの報告と、絶対ショート/ロングアドレッシング表記の情報
を下さった鎌田氏に感謝します。

　XC ver 1.01 のインクルードファイルを送っていただいたラキッ！氏に感謝し
ます。

　奇数アドレスへの分岐とサブルーチンコール命令の直後の引数への対応は、松
戸のロイヤルホストでひたすらオレンジジュースを待った三人の会話がきっかけ
で実現しました。

　FreeBSD クロス版のソース差分を送っていただき、ベータ版の動作試験にも協
力していただいた M.Suzuki 氏に感謝します。

　CygWin への対応にあたって、RuRuRu 氏の Win32 移植版を参考にさせていた
だきました。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	開発環境

────────────────────────────────────

gcc version 2.6.3 (68k, Human68k, revision 5)
					FSF / Charlie / KQ
HAS060 version 3.09+87+15[g2as]		Y.Nakamura / M.Kamada / 立花
HLK evolution version 3.01+14[g2lk]	SALT / 立花
GNU Make version 3.79 human68k-1.2	FSF (自分で移植版)
GNU Bison version 1.28 human68k-1.2	FSF (〃)
GNU diffutils version 2.7 human68k-1.3	FSF (〃)
MicroEMACS j1.43 (rel.5c7-beta4)	Sharl 他

libc-1.2.20 Release Mimu		Project C Library Group / 立花
libgcc version x.xx patchlevel 7	FSF / Charlie / 立花
libhdi ver2.9 (改)			oo / 立花
libhmem ver1.10b			oo
libld (level 1)				立花
libfroa version 0.10			〃	<- 使ってないけど

(敬称略)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	参考文献

────────────────────────────────────

ぷにぐらま〜ずまにゅある 第七版第二刷	立花＠桑島技研
C 言語による最新アルゴリズム事典	奥村晴彦, 技術評論社
68000 プログラマーズハンドブック	宍倉幸則, 〃
Inside X68000				堯野雅彦, SOFT BANK
X68030 Inside/Out			〃	, 〃
プログラミング言語 C 第二版		B.W.カーニハン / D.M.リッチー
					石田晴久訳, 共立出版
MC68030 ユーザーズ・マニュアル		日本モトローラ
M68000 FAMILY PROGRAMMER'S REFERENCE MANUAL
					MOTOROLA

has version 3.09			中村祐一
HAS060 version 3.09+87			鎌田誠
060turbo.sys version 0.54		〃
README.DOC (060turbo.sys version 0.44)	〃
dis.x version 2.78 patchlevel +04	Ｓｙｏ

(敬称略)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

	連絡先

────────────────────────────────────

立花＠桑島技研

桑島技研Ｏｎｌｉｎｅ
  http://kuwa.xps.jp/

E-Mail:
  shimazaki.ryo@gmail.com


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
